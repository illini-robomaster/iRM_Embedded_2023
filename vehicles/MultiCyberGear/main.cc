/****************************************************************************
 *                                                                          *
 *  Copyright (C) 2023 RoboMaster.                                          *
 *  Illini RoboMaster @ University of Illinois at Urbana-Champaign          *
 *                                                                          *
 *  This program is free software: you can redistribute it and/or modify    *
 *  it under the terms of the GNU General Public License as published by    *
 *  the Free Software Foundation, either version 3 of the License, or       *
 *  (at your option) any later version.                                     *
 *                                                                          *
 *  This program is distributed in the hope that it will be useful,         *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 *  GNU General Public License for more details.                            *
 *                                                                          *
 *  You should have received a copy of the GNU General Public License       *
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.    *
 *                                                                          *
 ****************************************************************************/

#include <cmath>

#include "bsp_print.h"
#include "bsp_os.h"
#include "bsp_gpio.h"
#include "cmsis_os2.h"
#include "main.h"

#include "cybergear.h"

#define MOTOR_BASE_ID 126
#define MOTOR_ARM1_ID 127

#define MOTOR_BASE_TARGET_ANGLE (-0.4049)
#define MOTOR_ARM1_TARGET_ANGLE (-1.785)

#define KP 5.0
#define KD 0.6

#define MOTOR_WEIGHT 0.317
#define ARM1_LENGTH 0.13
#define GRAVITY 9.8

#include <Eigen/Dense>

namespace sym {

/**
 * This function was autogenerated. Do not modify by hand.
 *
 * Args:
 *     t1: Scalar
 *     tdot1: Scalar
 *     t2: Scalar
 *     tdot2: Scalar
 *     m: Scalar
 *     dt: Scalar
 *     l: Scalar
 *     g: Scalar
 *     tau1: Scalar
 *     tau2: Scalar
 *
 * Outputs:
 *     f: Matrix51
 *     A_mat: Matrix55
 *     B_mat: Matrix52
 */
template <typename Scalar>
void Forward(const Scalar t1, const Scalar tdot1, const Scalar t2, const Scalar tdot2,
             const Scalar m, const Scalar dt, const Scalar l, const Scalar g, const Scalar tau1,
             const Scalar tau2, Eigen::Matrix<Scalar, 5, 1>* const f = nullptr,
             Eigen::Matrix<Scalar, 5, 5>* const A_mat = nullptr,
             Eigen::Matrix<Scalar, 5, 2>* const B_mat = nullptr) {
  // Total ops: 44

  // Input arrays

  // Intermediate terms (13)
  const Scalar _tmp0 = std::pow(l, Scalar(2));
  const Scalar _tmp1 = _tmp0 * m;
  const Scalar _tmp2 = std::sin(t2);
  const Scalar _tmp3 = std::pow(_tmp2, Scalar(2)) * dt;
  const Scalar _tmp4 = _tmp1 * _tmp3 + Scalar(1.0000000000000001e-9);
  const Scalar _tmp5 = Scalar(1.0) / (_tmp4);
  const Scalar _tmp6 = _tmp2 * g * l * m + tau2;
  const Scalar _tmp7 = Scalar(1.0) / (m);
  const Scalar _tmp8 = dt / _tmp0;
  const Scalar _tmp9 = _tmp7 * _tmp8;
  const Scalar _tmp10 = dt * std::cos(t2);
  const Scalar _tmp11 = tau1 / std::pow(_tmp4, Scalar(2));
  const Scalar _tmp12 = g / l;

  // Output terms (3)
  if (f != nullptr) {
    Eigen::Matrix<Scalar, 5, 1>& _f = (*f);

    _f(0, 0) = dt * tdot1 + t1;
    _f(1, 0) = _tmp5 * tau1 + tdot1;
    _f(2, 0) = dt * tdot2 + t2;
    _f(3, 0) = _tmp6 * _tmp9 + tdot2;
    _f(4, 0) = m;
  }

  if (A_mat != nullptr) {
    Eigen::Matrix<Scalar, 5, 5>& _A_mat = (*A_mat);

    _A_mat.setZero();

    _A_mat(0, 0) = 1;
    _A_mat(0, 1) = dt;
    _A_mat(1, 1) = 1;
    _A_mat(1, 2) = -2 * _tmp1 * _tmp10 * _tmp11 * _tmp2;
    _A_mat(2, 2) = 1;
    _A_mat(3, 2) = _tmp10 * _tmp12;
    _A_mat(2, 3) = dt;
    _A_mat(3, 3) = 1;
    _A_mat(1, 4) = -_tmp0 * _tmp11 * _tmp3;
    _A_mat(3, 4) = _tmp12 * _tmp2 * _tmp7 * dt - _tmp6 * _tmp8 / std::pow(m, Scalar(2));
    _A_mat(4, 4) = 1;
  }

  if (B_mat != nullptr) {
    Eigen::Matrix<Scalar, 5, 2>& _B_mat = (*B_mat);

    _B_mat.setZero();

    _B_mat(1, 0) = _tmp5;
    _B_mat(3, 1) = _tmp9;
  }
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym


class KalmanFilter {
public:
  KalmanFilter() {
    // construct C
    C.col(4).setZero();
    C.block<4, 4>(0, 0).setIdentity();

    // construct Q
    Q.setZero();
    Q(0, 0) = 1e-4;
    Q(1, 1) = 1e-4;
    Q(2, 2) = 1e-4;
    Q(3, 3) = 1e-4;
    Q(4, 4) = 1e-8;

    // construct R
    R.setZero();
    R(0, 0) = 1e-4;
    R(1, 1) = 1e-4;
    R(2, 2) = 1e-4;
    R(3, 3) = 1e-4;
  }

  void Update(double tau1, double tau2, double theta1, double dtheta1, double theta2, double dtheta2, double dt) {
    Eigen::Matrix<double, 5, 1> x_pred;
    Eigen::Matrix<double, 5, 5> P_pred;
    Eigen::Matrix<double, 5, 5> A;
    Eigen::Matrix<double, 5, 2> B;

    // prediction update
    sym::Forward<double>(x[0], x[1], x[2], x[3], x[4], dt, ARM1_LENGTH, GRAVITY, tau1, tau2, &x_pred, &A, &B);
    P_pred = A * P * A.transpose() + Q;

    // measurement update
    Eigen::Vector4d z(theta1, dtheta1, theta2, dtheta2);
    Eigen::Vector4d innovation = z - x.block<4, 1>(0, 0);
    innovation[0] = std::remainder(innovation[0], 2.0 * M_PI);
    innovation[2] = std::remainder(innovation[2], 2.0 * M_PI);
    Eigen::Matrix<double, 4, 4> S = C * P_pred * C.transpose() + R;
    Eigen::Matrix<double, 5, 4> K = P_pred * C.transpose() * S.inverse();
    x = x_pred + K * innovation;
    P = P_pred - K * C * P_pred;
  }

  void MeasurementUpdate();

private:
  Eigen::Matrix<double, 5, 1> x;
  Eigen::Matrix<double, 5, 5> P;
  Eigen::Matrix<double, 4, 5> C;
  Eigen::Matrix<double, 5, 5> Q;
  Eigen::Matrix<double, 4, 4> R;
};


const osTimerAttr_t controlTimerAttribute = {
  .name = "controlTimer",
  .attr_bits = 0,
  .cb_mem = nullptr,
  .cb_size = 0,
};

osTimerId_t controlTimer;

static xiaomi::CAN* can = nullptr;
static xiaomi::CyberGear* motor_base = nullptr;
static xiaomi::CyberGear* motor_arm1 = nullptr;
static bsp::GPIO* key = nullptr;

void controlTask(void* arg) {
  UNUSED(arg);

  if (key->Read()) {
    motor_base->SendPositionCommand(0.0);
    motor_arm1->SendPositionCommand(0.0);
  } else {
    motor_base->SendPositionCommand(0.1);
    motor_arm1->SendPositionCommand(0.0);
  }
}

//==================================================================================================
// RM Init
//==================================================================================================

void RM_RTOS_Init(void) {
  print_use_usb();

  bsp::SetHighresClockTimer(&htim5);

  key = new bsp::GPIO(KEY_GPIO_Port, KEY_Pin);
  can = new xiaomi::CAN(&hcan1);
  motor_base = new xiaomi::CyberGear(can, MOTOR_BASE_ID, xiaomi::Position_mode);
  motor_arm1 = new xiaomi::CyberGear(can, MOTOR_ARM1_ID, xiaomi::Position_mode);
}

void RM_RTOS_Timers_Init(void) {
  controlTimer = osTimerNew(controlTask, osTimerPeriodic, nullptr, &controlTimerAttribute);
}

//==================================================================================================
// RM Default Task
//==================================================================================================

void RM_RTOS_Default_Task(const void* arg) {
  UNUSED(arg);

  motor_base->SetZeroPosition();
  motor_arm1->SetZeroPosition();

  motor_base->SetSpeedKi(0.);
  motor_arm1->SetSpeedKi(0.);
  motor_base->SetPositionKp(10.);
  motor_arm1->SetPositionKp(10.);
  motor_base->SetSpeedKp(1.);
  motor_arm1->SetSpeedKp(1.);

  osDelay(10);

  osTimerStart(controlTimer, 1U);

  while (true) {
    print("arm1 torque: %.4f\r\n", motor_arm1->GetTorque());

    osDelay(10);
  }
}

//==================================================================================================
// END
//==================================================================================================
