/****************************************************************************
 *                                                                          *
 *  Copyright (C) 2023 RoboMaster.                                          *
 *  Illini RoboMaster @ University of Illinois at Urbana-Champaign          *
 *                                                                          *
 *  This program is free software: you can redistribute it and/or modify    *
 *  it under the terms of the GNU General Public License as published by    *
 *  the Free Software Foundation, either version 3 of the License, or       *
 *  (at your option) any later version.                                     *
 *                                                                          *
 *  This program is distributed in the hope that it will be useful,         *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 *  GNU General Public License for more details.                            *
 *                                                                          *
 *  You should have received a copy of the GNU General Public License       *
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.    *
 *                                                                          *
 ****************************************************************************/

#include <cmath>

#include "bsp_print.h"
#include "bsp_os.h"
#include "bsp_gpio.h"
#include "cmsis_os2.h"
#include "main.h"

#include "cybergear.h"

#define MOTOR_BASE_ID 127
#define MOTOR_ARM1_ID 126

#define MOTOR_BASE_TARGET_ANGLE (-0.4049)
#define MOTOR_ARM1_TARGET_ANGLE (-1.785)

#define KP 5.0
#define KD 0.6

#define MOTOR_WEIGHT 0.317
#define ARM1_LENGTH 0.13
#define GRAVITY 9.8

#include <Eigen/Dense>

namespace sym {

/**
 * This function was autogenerated. Do not modify by hand.
 *
 * Args:
 *     t1: Scalar
 *     tdot1: Scalar
 *     t2: Scalar
 *     tdot2: Scalar
 *     m: Scalar
 *     dt: Scalar
 *     l: Scalar
 *     g: Scalar
 *     tau1: Scalar
 *     tau2: Scalar
 *
 * Outputs:
 *     f: Matrix51
 *     A_mat: Matrix55
 *     B_mat: Matrix52
 */
template <typename Scalar>
void Forward(const Scalar t1, const Scalar tdot1, const Scalar t2, const Scalar tdot2,
             const Scalar m, const Scalar dt, const Scalar l, const Scalar g, const Scalar tau1,
             const Scalar tau2, Eigen::Matrix<Scalar, 5, 1>* const f = nullptr,
             Eigen::Matrix<Scalar, 5, 5>* const A_mat = nullptr,
             Eigen::Matrix<Scalar, 5, 2>* const B_mat = nullptr) {
  // Total ops: 43

  // Input arrays

  // Intermediate terms (13)
  const Scalar _tmp0 = std::pow(l, Scalar(2));
  const Scalar _tmp1 = std::sin(t2);
  const Scalar _tmp2 = _tmp0 * std::pow(_tmp1, Scalar(2)) * dt;
  const Scalar _tmp3 = _tmp2 * m + Scalar(0.10000000000000001);
  const Scalar _tmp4 = Scalar(1.0) / (_tmp3);
  const Scalar _tmp5 = _tmp1 * m;
  const Scalar _tmp6 = _tmp5 * g * l + tau2;
  const Scalar _tmp7 = Scalar(1.0) / (m);
  const Scalar _tmp8 = dt / _tmp0;
  const Scalar _tmp9 = _tmp7 * _tmp8;
  const Scalar _tmp10 = dt * std::cos(t2);
  const Scalar _tmp11 = tau1 / std::pow(_tmp3, Scalar(2));
  const Scalar _tmp12 = g / l;

  // Output terms (3)
  if (f != nullptr) {
    Eigen::Matrix<Scalar, 5, 1>& _f = (*f);

    _f(0, 0) = dt * tdot1 + t1;
    _f(1, 0) = _tmp4 * tau1 + tdot1;
    _f(2, 0) = dt * tdot2 + t2;
    _f(3, 0) = _tmp6 * _tmp9 + tdot2;
    _f(4, 0) = m;
  }

  if (A_mat != nullptr) {
    Eigen::Matrix<Scalar, 5, 5>& _A_mat = (*A_mat);

    _A_mat.setZero();

    _A_mat(0, 0) = 1;
    _A_mat(0, 1) = dt;
    _A_mat(1, 1) = 1;
    _A_mat(1, 2) = -2 * _tmp0 * _tmp10 * _tmp11 * _tmp5;
    _A_mat(2, 2) = 1;
    _A_mat(3, 2) = _tmp10 * _tmp12;
    _A_mat(2, 3) = dt;
    _A_mat(3, 3) = 1;
    _A_mat(1, 4) = -_tmp11 * _tmp2;
    _A_mat(3, 4) = _tmp1 * _tmp12 * _tmp7 * dt - _tmp6 * _tmp8 / std::pow(m, Scalar(2));
    _A_mat(4, 4) = 1;
  }

  if (B_mat != nullptr) {
    Eigen::Matrix<Scalar, 5, 2>& _B_mat = (*B_mat);

    _B_mat.setZero();

    _B_mat(1, 0) = _tmp4;
    _B_mat(3, 1) = _tmp9;
  }
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym


class KalmanFilter {
public:
  KalmanFilter() {
    // initialize x
    x.setZero();
    x[4] = 0.1;

    // initialize P
    P.setIdentity();

    // construct C
    C.col(4).setZero();
    C.block<4, 4>(0, 0).setIdentity();

    // construct Q
    Q.setZero();
    Q(0, 0) = 1e-6;
    Q(1, 1) = 1e-2;
    Q(2, 2) = 1e-6;
    Q(3, 3) = 1e-2;
    Q(4, 4) = 1e-8;

    // construct R
    R.setZero();
    R(0, 0) = 1e-6;
    R(1, 1) = 1e-4;
    R(2, 2) = 1e-6;
    R(3, 3) = 1e-4;
  }

  void Update(float tau1, float tau2, float theta1, float dtheta1, float theta2, float dtheta2, float dt) {
    Eigen::Matrix<float, 5, 1> x_pred;
    Eigen::Matrix<float, 5, 5> P_pred;
    Eigen::Matrix<float, 5, 5> A;
    Eigen::Matrix<float, 5, 2> B;

    // prediction update
    sym::Forward<float>(x[0], x[1], x[2], x[3], x[4], dt, ARM1_LENGTH, GRAVITY, tau1, tau2, &x_pred, &A, &B);
    P_pred = A * P * A.transpose() + Q;

    // measurement update
    Eigen::Vector4f z(theta1, dtheta1, theta2, dtheta2);
    Eigen::Vector4f innovation = z - x.block<4, 1>(0, 0);
    innovation[0] = std::remainder(innovation[0], 2.0 * M_PI);
    innovation[2] = std::remainder(innovation[2], 2.0 * M_PI);
    Eigen::Matrix<float, 4, 4> S = C * P_pred * C.transpose() + R;
    Eigen::Matrix<float, 5, 4> K = P_pred * C.transpose() * S.inverse();
    x = x_pred + K * innovation;
    P = P_pred - K * C * P_pred;
  }

  const Eigen::Matrix<float, 5, 1> GetState() const {
    return x;
  }

private:
  Eigen::Matrix<float, 5, 1> x;
  Eigen::Matrix<float, 5, 5> P;
  Eigen::Matrix<float, 4, 5> C;
  Eigen::Matrix<float, 5, 5> Q;
  Eigen::Matrix<float, 4, 4> R;
};


osTimerId_t controlTimer;
const osTimerAttr_t controlTimerAttribute = {
  .name = "controlTimer",
  .attr_bits = 0,
  .cb_mem = nullptr,
  .cb_size = 0,
};

osTimerId_t targetTimer;
const osTimerAttr_t targetTimerAttribute = {
  .name = "targetTimer",
  .attr_bits = 0,
  .cb_mem = nullptr,
  .cb_size = 0,
};

static xiaomi::CAN* can = nullptr;
static xiaomi::CyberGear* motor_base = nullptr;
static xiaomi::CyberGear* motor_arm1 = nullptr;
static bsp::GPIO* key = nullptr;
static KalmanFilter filter;

static float base_angles[] = {-1.0, -0.5, 0., 0.5, 1.0, 0.5, 0., -0.5};
static float arm_angles[] = {0.0, 0.4, 0.8, 1.2, 1.6, 1.2, 0.8, 0.4};
int base_idx = 0;
int arm_idx = 0;

void controlTask(void* arg) {
  UNUSED(arg);

  if (base_idx >= 0 && base_idx < 8) {
    motor_base->SendPositionCommand(base_angles[base_idx]);
  }
  if (arm_idx >= 0 && arm_idx < 8) {
    motor_arm1->SendPositionCommand(arm_angles[arm_idx]);
  }

  filter.Update(motor_base->GetTorque(), -motor_arm1->GetTorque(), motor_base->GetAngle(), motor_base->GetSpeed() * 2. * M_PI / 60., -motor_arm1->GetAngle(), -motor_arm1->GetSpeed() * 2. * M_PI / 60., 0.002);
}

void targetTask(void* arg) {
  UNUSED(arg);

  base_idx = (base_idx + 1) % 8;
  if (base_idx % 8 == 0) {
    arm_idx = (arm_idx + 1) % 8;
  }
}

void estimateTask(void* arg) {
  UNUSED(arg);
}

//==================================================================================================
// RM Init
//==================================================================================================

void RM_RTOS_Init(void) {
  print_use_usb();

  bsp::SetHighresClockTimer(&htim5);

  key = new bsp::GPIO(KEY_GPIO_Port, KEY_Pin);
  can = new xiaomi::CAN(&hcan1);
  motor_base = new xiaomi::CyberGear(can, MOTOR_BASE_ID, xiaomi::Position_mode);
  motor_arm1 = new xiaomi::CyberGear(can, MOTOR_ARM1_ID, xiaomi::Position_mode);
}

void RM_RTOS_Timers_Init(void) {
  controlTimer = osTimerNew(controlTask, osTimerPeriodic, nullptr, &controlTimerAttribute);
  targetTimer = osTimerNew(targetTask, osTimerPeriodic, nullptr, &targetTimerAttribute);
}

//==================================================================================================
// RM Default Task
//==================================================================================================

void RM_RTOS_Default_Task(const void* arg) {
  UNUSED(arg);

  motor_base->SetZeroPosition();
  motor_arm1->SetZeroPosition();

  motor_base->SendPositionCommand(0.0);
  motor_arm1->SendPositionCommand(0.0);
  osDelay(1000);

  motor_base->SetSpeedKi(0.002);
  motor_arm1->SetSpeedKi(0.002);
  motor_base->SetPositionKp(30.);
  motor_arm1->SetPositionKp(30.);
  motor_base->SetSpeedKp(2.);
  motor_arm1->SetSpeedKp(2.);
  osDelay(10);

  osTimerStart(controlTimer, 2U);
  osDelay(100);
  osTimerStart(targetTimer, 1000U);

  while (true) {
    const Eigen::Matrix<float, 5, 1> state = filter.GetState();

    print("estimated mass: %.4f\r\n", state[4]);

    osDelay(10);
  }
}

//==================================================================================================
// END
//==================================================================================================
